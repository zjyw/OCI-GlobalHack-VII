{"version":3,"sources":["public/src/modules/translator.js"],"names":["factory","loadClient","language","namespace","Promise","resolve","jQuery","getJSON","config","relative_path","warn","console","apply","arguments","define","amd","utils","module","exports","languages","require","global","env","winston","a","loadServer","reject","get","err","data","load","assign","Object","extend","escapeHTML","str","decodeHTMLEntities","String","replace","Translator","self","this","TypeError","modules","keys","moduleFactories","map","reduce","prev","elem","lang","translations","prototype","translate","validText","validTextRegex","RegExp","invalidTextRegex","cursor","lastBreak","len","length","toTranslate","inToken","split","text","arr","i","brk","level","push","slice","trim","indexOf","char0","char1","textBeforeColonFound","colonFound","textAfterColonFound","commaAfterNameFound","test","currentSlice","result","name","args","backup","translateKey","last","all","then","translated","join","key","translation","getTranslation","argsToTranslate","arg","translatedArgs","out","forEach","escaped","catch","x","descendantTextNodes","node","textNodes","helper","nodeType","c","childNodes","l","translateInPlace","element","attributes","nodes","nodeValue","attrNodes","attr","tuples","Array","call","querySelectorAll","el","concat","attrText","getAttribute","ref","translatedAttrs","html","$","replaceWith","setAttribute","getLanguage","window","params","userLang","defaultLang","meta","create","cache","registerModule","translator","removePatterns","sub","escape","unescape","compile","adaptor","callback","cb","output","setTimeout","stack","addTranslation","getTranslations","toggleTimeagoShorthand","toggle","tmp","timeago","settings","strings","timeagoShort","languageCode","userLangToTimeagoCode","originalSettings","getScript","done","prepareDOM","value","css"],"mappings":"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","file":"public/src/modules/translator.js","sourcesContent":["'use strict';\n\n(function (factory) {\n\tfunction loadClient(language, namespace) {\n\t\treturn Promise.resolve(jQuery.getJSON(config.relative_path + '/assets/language/' + language + '/' + namespace + '.json?' + config['cache-buster']));\n\t}\n\tvar warn = function () { console.warn.apply(console, arguments); };\n\tif (typeof define === 'function' && define.amd) {\n\t\t// AMD. Register as a named module\n\t\tdefine('translator', [], function () {\n\t\t\treturn factory(utils, loadClient, warn);\n\t\t});\n\t} else if (typeof module === 'object' && module.exports) {\n\t\t// Node\n\t\t(function () {\n\t\t\tvar languages = require('../../../src/languages');\n\n\t\t\tif (global.env === 'development') {\n\t\t\t\tvar winston = require('winston');\n\t\t\t\twarn = function (a) {\n\t\t\t\t\twinston.warn(a);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfunction loadServer(language, namespace) {\n\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\tlanguages.get(language, namespace, function (err, data) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tmodule.exports = factory(require('../utils'), loadServer, warn);\n\t\t}());\n\t}\n}(function (utils, load, warn) {\n\tvar assign = Object.assign || jQuery.extend;\n\n\tfunction escapeHTML(str) {\n\t\treturn utils.escapeHTML(utils.decodeHTMLEntities(\n\t\t\tString(str)\n\t\t\t\t.replace(/[\\s\\xa0]+/g, ' ')\n\t\t\t\t.replace(/^\\s+|\\s+$/g, '')\n\t\t));\n\t}\n\n\tvar Translator = (function () {\n\t\t/**\n\t\t * Construct a new Translator object\n\t\t * @param {string} language - Language code for this translator instance\n\t\t * @exports translator.Translator\n\t\t */\n\t\tfunction Translator(language) {\n\t\t\tvar self = this;\n\n\t\t\tif (!language) {\n\t\t\t\tthrow new TypeError('Parameter `language` must be a language string. Received ' + language + (language === '' ? '(empty string)' : ''));\n\t\t\t}\n\n\t\t\tself.modules = Object.keys(Translator.moduleFactories).map(function (namespace) {\n\t\t\t\tvar factory = Translator.moduleFactories[namespace];\n\t\t\t\treturn [namespace, factory(language)];\n\t\t\t}).reduce(function (prev, elem) {\n\t\t\t\tvar namespace = elem[0];\n\t\t\t\tvar module = elem[1];\n\t\t\t\tprev[namespace] = module;\n\n\t\t\t\treturn prev;\n\t\t\t}, {});\n\n\t\t\tself.lang = language;\n\t\t\tself.translations = {};\n\t\t}\n\n\t\tTranslator.prototype.load = load;\n\n\t\t/**\n\t\t * Parse the translation instructions into the language of the Translator instance\n\t\t * @param {string} str - Source string\n\t\t * @returns {Promise<string>}\n\t\t */\n\t\tTranslator.prototype.translate = function translate(str) {\n\t\t\t// regex for valid text in namespace / key\n\t\t\tvar validText = 'a-zA-Z0-9\\\\-_.\\\\/';\n\t\t\tvar validTextRegex = new RegExp('[' + validText + ']');\n\t\t\tvar invalidTextRegex = new RegExp('[^' + validText + '\\\\]]');\n\n\t\t\t// current cursor position\n\t\t\tvar cursor = 0;\n\t\t\t// last break of the input string\n\t\t\tvar lastBreak = 0;\n\t\t\t// length of the input string\n\t\t\tvar len = str.length;\n\t\t\t// array to hold the promises for the translations\n\t\t\t// and the strings of untranslated text in between\n\t\t\tvar toTranslate = [];\n\n\t\t\t// to store the state of if we're currently in a top-level token for later\n\t\t\tvar inToken = false;\n\n\t\t\t// split a translator string into an array of tokens\n\t\t\t// but don't split by commas inside other translator strings\n\t\t\tfunction split(text) {\n\t\t\t\tvar len = text.length;\n\t\t\t\tvar arr = [];\n\t\t\t\tvar i = 0;\n\t\t\t\tvar brk = 0;\n\t\t\t\tvar level = 0;\n\n\t\t\t\twhile (i + 2 <= len) {\n\t\t\t\t\tif (text[i] === '[' && text[i + 1] === '[') {\n\t\t\t\t\t\tlevel += 1;\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t} else if (text[i] === ']' && text[i + 1] === ']') {\n\t\t\t\t\t\tlevel -= 1;\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t} else if (level === 0 && text[i] === ',' && text[i - 1] !== '\\\\') {\n\t\t\t\t\t\tarr.push(text.slice(brk, i).trim());\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tbrk = i;\n\t\t\t\t\t}\n\t\t\t\t\ti += 1;\n\t\t\t\t}\n\t\t\t\tarr.push(text.slice(brk, i + 1).trim());\n\t\t\t\treturn arr;\n\t\t\t}\n\n\t\t\t// move to the first [[\n\t\t\tcursor = str.indexOf('[[', cursor);\n\n\t\t\t// the loooop, we'll go to where the cursor\n\t\t\t// is equal to the length of the string since\n\t\t\t// slice doesn't include the ending index\n\t\t\twhile (cursor + 2 <= len && cursor !== -1) {\n\t\t\t\t// split the string from the last break\n\t\t\t\t// to the character before the cursor\n\t\t\t\t// add that to the result array\n\t\t\t\ttoTranslate.push(str.slice(lastBreak, cursor));\n\t\t\t\t// set the cursor position past the beginning\n\t\t\t\t// brackets of the translation string\n\t\t\t\tcursor += 2;\n\t\t\t\t// set the last break to our current\n\t\t\t\t// spot since we just broke the string\n\t\t\t\tlastBreak = cursor;\n\t\t\t\t// we're in a token now\n\t\t\t\tinToken = true;\n\n\t\t\t\t// the current level of nesting of the translation strings\n\t\t\t\tvar level = 0;\n\t\t\t\tvar char0;\n\t\t\t\tvar char1;\n\t\t\t\t// validating the current string is actually a translation\n\t\t\t\tvar textBeforeColonFound = false;\n\t\t\t\tvar colonFound = false;\n\t\t\t\tvar textAfterColonFound = false;\n\t\t\t\tvar commaAfterNameFound = false;\n\n\t\t\t\twhile (cursor + 2 <= len) {\n\t\t\t\t\tchar0 = str[cursor];\n\t\t\t\t\tchar1 = str[cursor + 1];\n\t\t\t\t\t// found some text after the double bracket,\n\t\t\t\t\t// so this is probably a translation string\n\t\t\t\t\tif (!textBeforeColonFound && validTextRegex.test(char0)) {\n\t\t\t\t\t\ttextBeforeColonFound = true;\n\t\t\t\t\t\tcursor += 1;\n\t\t\t\t\t// found a colon, so this is probably a translation string\n\t\t\t\t\t} else if (textBeforeColonFound && !colonFound && char0 === ':') {\n\t\t\t\t\t\tcolonFound = true;\n\t\t\t\t\t\tcursor += 1;\n\t\t\t\t\t// found some text after the colon,\n\t\t\t\t\t// so this is probably a translation string\n\t\t\t\t\t} else if (colonFound && !textAfterColonFound && validTextRegex.test(char0)) {\n\t\t\t\t\t\ttextAfterColonFound = true;\n\t\t\t\t\t\tcursor += 1;\n\t\t\t\t\t} else if (textAfterColonFound && !commaAfterNameFound && char0 === ',') {\n\t\t\t\t\t\tcommaAfterNameFound = true;\n\t\t\t\t\t\tcursor += 1;\n\t\t\t\t\t// a space or comma was found before the name\n\t\t\t\t\t// this isn't a translation string, so back out\n\t\t\t\t\t} else if (!(textBeforeColonFound && colonFound && textAfterColonFound && commaAfterNameFound) &&\n\t\t\t\t\t\t\tinvalidTextRegex.test(char0)) {\n\t\t\t\t\t\tcursor += 1;\n\t\t\t\t\t\tlastBreak -= 2;\n\t\t\t\t\t\t// no longer in a token\n\t\t\t\t\t\tinToken = false;\n\t\t\t\t\t\tif (level > 0) {\n\t\t\t\t\t\t\tlevel -= 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t// if we're at the beginning of another translation string,\n\t\t\t\t\t// we're nested, so add to our level\n\t\t\t\t\t} else if (char0 === '[' && char1 === '[') {\n\t\t\t\t\t\tlevel += 1;\n\t\t\t\t\t\tcursor += 2;\n\t\t\t\t\t// if we're at the end of a translation string\n\t\t\t\t\t} else if (char0 === ']' && char1 === ']') {\n\t\t\t\t\t\t// if we're at the base level, then this is the end\n\t\t\t\t\t\tif (level === 0) {\n\t\t\t\t\t\t\t// so grab the name and args\n\t\t\t\t\t\t\tvar currentSlice = str.slice(lastBreak, cursor);\n\t\t\t\t\t\t\tvar result = split(currentSlice);\n\t\t\t\t\t\t\tvar name = result[0];\n\t\t\t\t\t\t\tvar args = result.slice(1);\n\n\t\t\t\t\t\t\t// make a backup based on the raw string of the token\n\t\t\t\t\t\t\t// if there are arguments to the token\n\t\t\t\t\t\t\tvar backup = '';\n\t\t\t\t\t\t\tif (args && args.length) {\n\t\t\t\t\t\t\t\tbackup = this.translate(currentSlice);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// add the translation promise to the array\n\t\t\t\t\t\t\ttoTranslate.push(this.translateKey(name, args, backup));\n\t\t\t\t\t\t\t// skip past the ending brackets\n\t\t\t\t\t\t\tcursor += 2;\n\t\t\t\t\t\t\t// set this as our last break\n\t\t\t\t\t\t\tlastBreak = cursor;\n\t\t\t\t\t\t\t// and we're no longer in a translation string,\n\t\t\t\t\t\t\t// so continue with the main loop\n\t\t\t\t\t\t\tinToken = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// otherwise we lower the level\n\t\t\t\t\t\tlevel -= 1;\n\t\t\t\t\t\t// and skip past the ending brackets\n\t\t\t\t\t\tcursor += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// otherwise just move to the next character\n\t\t\t\t\t\tcursor += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// skip to the next [[\n\t\t\t\tcursor = str.indexOf('[[', cursor);\n\t\t\t}\n\n\t\t\t// ending string of source\n\t\t\tvar last = str.slice(lastBreak);\n\n\t\t\t// if we were mid-token, treat it as invalid\n\t\t\tif (inToken) {\n\t\t\t\tlast = this.translate(last);\n\t\t\t}\n\n\t\t\t// add the remaining text after the last translation string\n\t\t\ttoTranslate.push(last);\n\n\t\t\t// and return a promise for the concatenated translated string\n\t\t\treturn Promise.all(toTranslate).then(function (translated) {\n\t\t\t\treturn translated.join('');\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Translates a specific key and array of arguments\n\t\t * @param {string} name - Translation key (ex. 'global:home')\n\t\t * @param {string[]} args - Arguments for `%1`, `%2`, etc\n\t\t * @param {string|Promise<string>} backup - Text to use in case the key can't be found\n\t\t * @returns {Promise<string>}\n\t\t */\n\t\tTranslator.prototype.translateKey = function translateKey(name, args, backup) {\n\t\t\tvar self = this;\n\n\t\t\tvar result = name.split(':', 2);\n\t\t\tvar namespace = result[0];\n\t\t\tvar key = result[1];\n\n\t\t\tif (self.modules[namespace]) {\n\t\t\t\treturn Promise.resolve(self.modules[namespace](key, args));\n\t\t\t}\n\n\t\t\tif (namespace && !key) {\n\t\t\t\twarn('Missing key in translation token \"' + name + '\"');\n\t\t\t\treturn Promise.resolve('[[' + namespace + ']]');\n\t\t\t}\n\n\t\t\tvar translation = this.getTranslation(namespace, key);\n\t\t\treturn translation.then(function (translated) {\n\t\t\t\t// check if the translation is missing first\n\t\t\t\tif (!translated) {\n\t\t\t\t\twarn('Missing translation \"' + name + '\"');\n\t\t\t\t\treturn backup || key;\n\t\t\t\t}\n\n\t\t\t\tvar argsToTranslate = args.map(function (arg) {\n\t\t\t\t\treturn self.translate(escapeHTML(arg));\n\t\t\t\t});\n\n\t\t\t\treturn Promise.all(argsToTranslate).then(function (translatedArgs) {\n\t\t\t\t\tvar out = translated;\n\t\t\t\t\ttranslatedArgs.forEach(function (arg, i) {\n\t\t\t\t\t\tvar escaped = arg.replace(/%(?=\\d)/g, '&#37;').replace(/\\\\,/g, '&#44;');\n\t\t\t\t\t\tout = out.replace(new RegExp('%' + (i + 1), 'g'), escaped);\n\t\t\t\t\t});\n\t\t\t\t\treturn out;\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Load translation file (or use a cached version), and optionally return the translation of a certain key\n\t\t * @param {string} namespace - The file name of the translation namespace\n\t\t * @param {string} [key] - The key of the specific translation to getJSON\n\t\t * @returns {Promise<{ [key: string]: string } | string>}\n\t\t */\n\t\tTranslator.prototype.getTranslation = function getTranslation(namespace, key) {\n\t\t\tvar translation;\n\t\t\tif (!namespace) {\n\t\t\t\twarn('[translator] Parameter `namespace` is ' + namespace + (namespace === '' ? '(empty string)' : ''));\n\t\t\t\ttranslation = Promise.resolve({});\n\t\t\t} else {\n\t\t\t\tthis.translations[namespace] = this.translations[namespace] || this.load(this.lang, namespace).catch(function () { return {}; });\n\t\t\t\ttranslation = this.translations[namespace];\n\t\t\t}\n\n\t\t\tif (key) {\n\t\t\t\treturn translation.then(function (x) {\n\t\t\t\t\treturn x[key];\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn translation;\n\t\t};\n\n\t\t/**\n\t\t * @param {Node} node\n\t\t * @returns {Node[]}\n\t\t */\n\t\tfunction descendantTextNodes(node) {\n\t\t\tvar textNodes = [];\n\n\t\t\tfunction helper(node) {\n\t\t\t\tif (node.nodeType === 3) {\n\t\t\t\t\ttextNodes.push(node);\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i = 0, c = node.childNodes, l = c.length; i < l; i += 1) {\n\t\t\t\t\t\thelper(c[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thelper(node);\n\t\t\treturn textNodes;\n\t\t}\n\n\t\t/**\n\t\t * Recursively translate a DOM element in place\n\t\t * @param {Element} element - Root element to translate\n\t\t * @param {string[]} [attributes] - Array of node attributes to translate\n\t\t * @returns {Promise<void>}\n\t\t */\n\t\tTranslator.prototype.translateInPlace = function translateInPlace(element, attributes) {\n\t\t\tattributes = attributes || ['placeholder', 'title'];\n\n\t\t\tvar nodes = descendantTextNodes(element);\n\t\t\tvar text = nodes.map(function (node) {\n\t\t\t\treturn node.nodeValue;\n\t\t\t}).join('  ||  ');\n\n\t\t\tvar attrNodes = attributes.reduce(function (prev, attr) {\n\t\t\t\tvar tuples = Array.prototype.map.call(element.querySelectorAll('[' + attr + '*=\"[[\"]'), function (el) {\n\t\t\t\t\treturn [attr, el];\n\t\t\t\t});\n\t\t\t\treturn prev.concat(tuples);\n\t\t\t}, []);\n\t\t\tvar attrText = attrNodes.map(function (node) {\n\t\t\t\treturn node[1].getAttribute(node[0]);\n\t\t\t}).join('  ||  ');\n\n\t\t\treturn Promise.all([\n\t\t\t\tthis.translate(text),\n\t\t\t\tthis.translate(attrText),\n\t\t\t]).then(function (ref) {\n\t\t\t\tvar translated = ref[0];\n\t\t\t\tvar translatedAttrs = ref[1];\n\t\t\t\tif (translated) {\n\t\t\t\t\ttranslated.split('  ||  ').forEach(function (html, i) {\n\t\t\t\t\t\t$(nodes[i]).replaceWith(html);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (translatedAttrs) {\n\t\t\t\t\ttranslatedAttrs.split('  ||  ').forEach(function (text, i) {\n\t\t\t\t\t\tattrNodes[i][1].setAttribute(attrNodes[i][0], text);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Get the language of the current environment, falling back to defaults\n\t\t * @returns {string}\n\t\t */\n\t\tTranslator.getLanguage = function getLanguage() {\n\t\t\tvar lang;\n\n\t\t\tif (typeof window === 'object' && window.config && window.utils) {\n\t\t\t\tlang = utils.params().lang || config.userLang || config.defaultLang || 'en-GB';\n\t\t\t} else {\n\t\t\t\tvar meta = require('../../../src/meta');\n\t\t\t\tlang = meta.config.defaultLang || 'en-GB';\n\t\t\t}\n\n\t\t\treturn lang;\n\t\t};\n\n\t\t/**\n\t\t * Create and cache a new Translator instance, or return a cached one\n\t\t * @param {string} [language] - ('en-GB') Language string\n\t\t * @returns {Translator}\n\t\t */\n\t\tTranslator.create = function create(language) {\n\t\t\tif (!language) {\n\t\t\t\tlanguage = Translator.getLanguage();\n\t\t\t}\n\n\t\t\tTranslator.cache[language] = Translator.cache[language] || new Translator(language);\n\n\t\t\treturn Translator.cache[language];\n\t\t};\n\n\t\tTranslator.cache = {};\n\n\t\t/**\n\t\t * Register a custom module to handle translations\n\t\t * @param {string} namespace - Namespace to handle translation for\n\t\t * @param {Function} factory - Function to return the translation function for this namespace\n\t\t */\n\t\tTranslator.registerModule = function registerModule(namespace, factory) {\n\t\t\tTranslator.moduleFactories[namespace] = factory;\n\n\t\t\tObject.keys(Translator.cache).forEach(function (key) {\n\t\t\t\tvar translator = Translator.cache[key];\n\t\t\t\ttranslator.modules[namespace] = factory(translator.lang);\n\t\t\t});\n\t\t};\n\n\t\tTranslator.moduleFactories = {};\n\n\t\t/**\n\t\t * Remove the translator patterns from text\n\t\t * @param {string} text\n\t\t * @returns {string}\n\t\t */\n\t\tTranslator.removePatterns = function removePatterns(text) {\n\t\t\tvar len = text.length;\n\t\t\tvar cursor = 0;\n\t\t\tvar lastBreak = 0;\n\t\t\tvar level = 0;\n\t\t\tvar out = '';\n\t\t\tvar sub;\n\n\t\t\twhile (cursor < len) {\n\t\t\t\tsub = text.slice(cursor, cursor + 2);\n\t\t\t\tif (sub === '[[') {\n\t\t\t\t\tif (level === 0) {\n\t\t\t\t\t\tout += text.slice(lastBreak, cursor);\n\t\t\t\t\t}\n\t\t\t\t\tlevel += 1;\n\t\t\t\t\tcursor += 2;\n\t\t\t\t} else if (sub === ']]') {\n\t\t\t\t\tlevel -= 1;\n\t\t\t\t\tcursor += 2;\n\t\t\t\t\tif (level === 0) {\n\t\t\t\t\t\tlastBreak = cursor;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcursor += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout += text.slice(lastBreak, cursor);\n\t\t\treturn out;\n\t\t};\n\n\t\t/**\n\t\t * Escape translator patterns in text\n\t\t * @param {string} text\n\t\t * @returns {string}\n\t\t */\n\t\tTranslator.escape = function escape(text) {\n\t\t\treturn typeof text === 'string' ? text.replace(/\\[\\[/g, '&lsqb;&lsqb;').replace(/\\]\\]/g, '&rsqb;&rsqb;') : text;\n\t\t};\n\n\t\t/**\n\t\t * Unescape escaped translator patterns in text\n\t\t * @param {string} text\n\t\t * @returns {string}\n\t\t */\n\t\tTranslator.unescape = function unescape(text) {\n\t\t\treturn typeof text === 'string' ? text.replace(/&lsqb;|\\\\\\[/g, '[').replace(/&rsqb;|\\\\\\]/g, ']') : text;\n\t\t};\n\n\t\t/**\n\t\t * Construct a translator pattern\n\t\t * @param {string} name - Translation name\n\t\t * @param {...string} arg - Optional argument for the pattern\n\t\t */\n\t\tTranslator.compile = function compile() {\n\t\t\tvar args = Array.prototype.slice.call(arguments, 0).map(function (text) {\n\t\t\t\t// escape commas and percent signs in arguments\n\t\t\t\treturn String(text).replace(/%/g, '&#37;').replace(/,/g, '&#44;');\n\t\t\t});\n\n\t\t\treturn '[[' + args.join(', ') + ']]';\n\t\t};\n\n\t\treturn Translator;\n\t}());\n\n\t/**\n\t * @exports translator\n\t */\n\tvar adaptor = {\n\t\t/**\n\t\t * The Translator class\n\t\t */\n\t\tTranslator: Translator,\n\n\t\tcompile: Translator.compile,\n\t\tescape: Translator.escape,\n\t\tunescape: Translator.unescape,\n\t\tgetLanguage: Translator.getLanguage,\n\n\t\t/**\n\t\t * Legacy translator function for backwards compatibility\n\t\t */\n\t\ttranslate: function translate(text, language, callback) {\n\t\t\t// TODO: deprecate?\n\n\t\t\tvar cb = callback;\n\t\t\tvar lang = language;\n\t\t\tif (typeof language === 'function') {\n\t\t\t\tcb = language;\n\t\t\t\tlang = null;\n\t\t\t}\n\n\t\t\tif (!(typeof text === 'string' || text instanceof String) || text === '') {\n\t\t\t\treturn cb('');\n\t\t\t}\n\n\t\t\treturn Translator.create(lang).translate(text).then(function (output) {\n\t\t\t\tif (cb) {\n\t\t\t\t\tsetTimeout(cb, 0, output);\n\t\t\t\t}\n\t\t\t\treturn output;\n\t\t\t}, function (err) {\n\t\t\t\twarn('Translation failed: ' + err.stack);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Add translations to the cache\n\t\t */\n\t\taddTranslation: function addTranslation(language, namespace, translation) {\n\t\t\tTranslator.create(language).getTranslation(namespace).then(function (translations) {\n\t\t\t\tassign(translations, translation);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Get the translations object\n\t\t */\n\t\tgetTranslations: function getTranslations(language, namespace, callback) {\n\t\t\tcallback = callback || function () {};\n\t\t\tTranslator.create(language).getTranslation(namespace).then(callback);\n\t\t},\n\n\t\t/**\n\t\t * Alias of getTranslations\n\t\t */\n\t\tload: function load(language, namespace, callback) {\n\t\t\tadaptor.getTranslations(language, namespace, callback);\n\t\t},\n\n\t\ttoggleTimeagoShorthand: function toggleTimeagoShorthand(callback) {\n\t\t\tfunction toggle() {\n\t\t\t\tvar tmp = assign({}, jQuery.timeago.settings.strings);\n\t\t\t\tjQuery.timeago.settings.strings = assign({}, adaptor.timeagoShort);\n\t\t\t\tadaptor.timeagoShort = assign({}, tmp);\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!adaptor.timeagoShort) {\n\t\t\t\tvar languageCode = utils.userLangToTimeagoCode(config.userLang);\n\t\t\t\tvar originalSettings = assign({}, jQuery.timeago.settings.strings);\n\t\t\t\tjQuery.getScript(config.relative_path + '/assets/vendor/jquery/timeago/locales/jquery.timeago.' + languageCode + '-short.js').done(function () {\n\t\t\t\t\tadaptor.timeagoShort = assign({}, jQuery.timeago.settings.strings);\n\t\t\t\t\tjQuery.timeago.settings.strings = assign({}, originalSettings);\n\t\t\t\t\ttoggle();\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\ttoggle();\n\t\t\t}\n\t\t},\n\t\tprepareDOM: function prepareDOM() {\n\t\t\t// Add directional code if necessary\n\t\t\tadaptor.translate('[[language:dir]]', function (value) {\n\t\t\t\tif (value && !$('html').attr('data-dir')) {\n\t\t\t\t\tjQuery('html').css('direction', value).attr('data-dir', value);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t};\n\n\treturn adaptor;\n}));\n"]}